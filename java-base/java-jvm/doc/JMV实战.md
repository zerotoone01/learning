
JVM在什么情况下会加载一个类？  

JVM中有哪些内存区域，分别是用来干嘛的？  

在Java堆内存中分配的那些对象，到底会占用多少内存？一般怎么来计算和估算我们的系统创建的对象对内存占用的一个
压力呢？  
>一个对象对内存空间的占用，大致分为两块：
>一个是对象自己本身的一些信息
>一个是对象的实例变量作为数据占用的空间


JVM的垃圾回收机制是用来干嘛的？为什么要垃圾回收？  

JVM分代模型：年轻代和老年代，为什么要分成年轻代和老年代？
>垃圾回收算法处理更方便

方法区（永久代）内会不会进行垃圾回收？
>满足如下三个条件即可被回收： 
>
>1.该类的所有实例对象都已经从Java堆内存里被回收
>
>2.加载这个类的ClassLoader已经被回收
>
>3.对该类的Class对象没有任何引用

每个线程执行方法的时候，那些方法对应的栈帧出栈了，那么那里的局部变量需要垃圾回收吗？
>JVM里垃圾回收针对的是新生代，老年代，还有方法区（永久代），不会针对方法的栈帧
>
>方法一旦执行完毕，栈帧出栈，里面的局部变量直接就从内存里清理掉了。
>
如何根据系统的业务量来合理的设置JVM的堆内存大小？
>核心业务对象占用存储空间大小的10-20倍
>
>如果我们用2核4G的机器来部署，那么还是有点紧凑的，因为机器有4G内存，但是机器本身也要用一些内存空间，
>最后你的JVM进程最多就是2G内存，然后这2G还得分配给方法区、栈内存、堆内存几块区域，那么堆内存可能最多就是个1G多的内存空间。
>
>问题：如果搞活动业务量暴增，又该怎么设置呢？

每日百万交易的支付系统，如何设置JVM堆内存与永久代如何设置？
>
>

JVM中有哪些垃圾回收算法，每个算法各自的优劣？

年轻代和老年代分别适合什么样的垃圾回收算法？

JVM中都有哪些常见的垃圾回收器，各自的特点是什么？

>GC 在stop the world 时，是不允许新对象的创建的

到底是单线程进行垃圾回收好呢？还是多线程进行垃圾回收好呢？在不同的场景下有各自的优缺点吗？
>服务器上，是多核处理器，对于新生代垃圾回收算法，ParallelNew优于Serial，
>但是对于客服端上的Java程序，通常是单线程，如果采用多线程垃圾回收，反而增加了线程的上下文切换时间，采用单线程GC更好
>

为什么老年代的垃圾回收速度会比新生代的垃圾回收速度慢很多倍？到底慢在哪里？
>对老年代所有对象进行GC Roots追踪，最耗时。 
>对于CMS而言，分为四阶段（初试标记-stw，并发标记，重新标记-stw\三色标记法，并发清理），初始标记只标记GC Roots，会发生STW，但很快；比较耗时的是并发标记，要根据GC Roots去标记所有的对象

>CMS默认启动的垃圾回收线程的数量是（CPU核数 + 3）/ 4
>
>Concurrent Mode Failure问题:
>造成原因：新生代对象转换到老年代，但是老年代空间不够了。
>

ParNew + CMS的组合让我们有哪些痛点？

G1垃圾回收器
>G1垃圾回收器是把Java堆内存拆分为多个大小相等的Region，可以同时回收新生代和老年代的对象的，不需要两个垃圾回收器配合起来运作,
>最大的一个特点，就是可以设置一个垃圾回收的预期停顿时间
>
>
G1是如何做到对垃圾回收导致的系统停顿可控的？
>把内存拆分为大量小Region，以及追踪每个Region中可以回收的对象大小和预估时间，
>最后在垃圾回收的时候，尽量把垃圾回收对系统造成的影响控制在你指定的时间范围内，
>同时在有限的时间内尽量回收尽可能多的垃圾对象。
>
G1到底有多少个Region呢？每个Region的大小是多大呢？
>JVM启动的时候一旦发现你使用的是G1垃圾回收器，可以使用“-XX:+UseG1GC”来指定使用G1垃圾回收器，此时会自动用堆大小除以2048
>JVM最多可以有2048个Region，然后Region的大小必须是2的倍数，比如说1MB、2MB、4MB之类的
>

G1 调优准则： 避免存活对象太多快速的进入到老年代，频繁的出发mixed gc

JVM性能优化到底在优化什么？
>系统真正最大的问题，就是因为内存分配、参数设置不合理，导致你的对象频繁的进入老年代，然后频繁触发老年代gc，导致系统频繁的每隔几分钟就要卡死几秒钟。
>老年代gc通常来说都很耗费时间(至少比新生代慢10倍以上)，无论是CMS垃圾回收器还是G1垃圾回收器都如此，
>一旦因为jvm内存分配不合理，导致频繁进行老年代gc，比如说几分钟就有一次老年代gc，每次gc系统都停顿几秒钟，那简直对系统就是致命的打击。
>

快速进入老年代的原因
>第一个，对象年龄太大了，这种对象一般很少，都是系统中确实需要长期存在的核心组件，他们一般不需要被回收掉，所以在新生代熬
 过默认15次垃圾回收之后就会进入老年代。
>
>第二个，动态年龄判定规则，如果一次新生代gc过后，发现Survivor区域中的几个年龄的对象加起来超过了Survivor区域的50%，
>比如说年龄1+年龄2+年龄3的对象大小总和，超过了Survivor区域的50%，此时就会把年龄3以上的对象都放入老年代。
>
>第三个，新生代垃圾回收过后，存活对象太多了，无法放入 Survivor 中，此时直接进入老年代。
>
>上述条件中，第二个和第三个都是很关键的，通常如果你的新生代中的Survivor区域内存过小，就会导致上述第二个和第三个条件
 频繁发生，然后导致大量对象快速进入老年代，进而频繁触发老年代的gc